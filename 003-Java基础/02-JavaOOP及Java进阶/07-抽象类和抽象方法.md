# 抽象方法和抽象类

**抽象类：** 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 

**抽象方法：**抽象类不能实例化对象，所以抽象类必须被继承，才能被使用 ， 父类包含了子类的常见的方法，但是由于父类本身是抽象的，所以无法具体实现这些方法，交给子类去实现。这种父类拥有定义，但是没有具体实现的方法，就是抽象方法。 

**抽象类和抽象方法的特征：**

（1）抽象类不能被实例化。

（2）抽象类中可以有，也可以没有抽象方法，抽象类中也可以有普通方法。但是只有要抽象方法，这个类一定是抽象类。

（3）子类必须重写抽象类中的所有抽象方法。（除非子类仍然还是抽象类）。

（4）抽象类中的抽象方法不需要实现的（而普通的子类重写父类方法，父类需要具体实现）。

**抽象方法和普通方法重写的区别：**

（1）抽象方法没有具体实现，普通的重写父类方法有具体实现。

（2）抽象方法子类必须重写，普通的父类方法子类可以重写也可以不重写。

**案例：抽象类和抽象方法的基本应用**

有一个父类Employee（员工）类：

```
//abstract关键字表示此类是一个抽象类
public abstract class Employee {
	//此方法是一个普通方法
    public void Meeting()
    {
        System.out.println("我在努力开会........");
    }
    //此方法使用abstract关键字，是一个抽象方法，只有定义，没有具体实现。
    public abstract void Working();
}
```

有一个子类Programmer（程序员）类:

```
public class Programmer extends Employee
{
	//此时作为子类，必须重写父类的Working抽象方法。
	@Override 
	public void Working() {
		System.out.println("我在努力敲代码........");
		
	}
}
```

备注：@Override代表重写，如果没有此关键字程序含义不变，但是添加此关键字会检查重写语法，例如，子类中方法名Working单词写错，添加了@Override会报错给出提示，而不添加@Override，程序会认为这不是一个重写，是一个全新的方法。

在main方法中实例化Programmer，调用Working方法会执行子类中的具体实现。

```
Programmer p = new Programmer();
p.Meeting();
p.Working();
```

