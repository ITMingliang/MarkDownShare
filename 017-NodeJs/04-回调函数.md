# 回调函数

Node.js 异步编程的直接体现就是回调。

异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。

回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。

例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数回。

这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。

回调函数一般作为函数的最后一个参数出现：

```
function foo1(name, age, callback) { }
function foo2(value, callback1, callback2) { }
```

## 一、阻塞代码实例

在项目中创建一个input.txt，内容如下：

```
安静无言并不是陷入空白，而是有一个更深广、更澄明的所在。
```

项目中创建main.js，内容如下：

```
var fs = require("fs");
var data = fs.readFileSync('input.txt');
console.log(data.toString());
console.log("程序执行结束!");
```

程序执行结果为：

```
node main.js
安静无言并不是陷入空白，而是有一个更深广、更澄明的所在。
程序执行结束!
```

以上代码先读取文件内容之后，才能打印“程序执行结束!”。

## 二、非阻塞代码实例

在项目中创建一个input.txt，内容如下：

```
安静无言并不是陷入空白，而是有一个更深广、更澄明的所在。
```

项目中创建main.js，内容如下：

```
var fs = require("fs");
fs.readFile('input.txt', function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});
console.log("程序执行结束!");
```

程序执行结果为：

```
node main.js
程序执行结束!
安静无言并不是陷入空白，而是有一个更深广、更澄明的所在。
```

以上代码可能会先打印“程序执行结束!”，然后读取文件内容。

## 三、以上两种模式的区别

以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行程序。 第二个实例我们不

需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。

因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回

调函数内。

